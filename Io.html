<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Io</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="icon" href="images/Self/game_icon.png">
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">SEYHYUN YANG</a>
				<nav>
					<ul>
						<li><a href="index.html">HOME</a></li>
						<li><a href="Projects.html" class="active">PROJECTS</a></li>
						<li><a href="DevBlog.html">DEV BLOGS</a></li>
						<li><a href="AboutMe.html" >ABOUT ME</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper style1 fullscreen fade-up"">
						<div class="inner">
							<h1 class="major">Io</h1>
							<span class="image fit"><a href="https://wolverinesoft-studio.itch.io/io" class="image">
								<img src="images/Io/Io_title.png" alt="" /></span></a>
							<h2>ABOUT</h2>
							<p>A long term project completed over the course of a semester by around 90 University of Michigan students, Io is a
								2d action platformer with tense combat, high mobility, and difficult platforming and a final 
								boss, all utillizing the unique teloportation mechanic.</p>
							<h2>DEVELOPMENT INFO</h2>
							<ul>
								<li>
									Developed by WolverineSoft Studio
								</li>
								<li>
									3 month development cycle (02/04/2020 - 5/04/2020)
								</li>
								<li>
									90 developers
								</li>
								<li>
									Made using Unity Engine
								</li>
							</ul>
							<h2>CONTRIBUTIONS</h2>
							<ul>
								<li>
									Programmer
								</li>
						</div>
					</section>
					<section id="main" class="wrapper style2 fullscreen fade-up"">
						<div class="inner">
							<h1 class="major">POST-MORTEM</h1>
							<img src="images/Io/Io_1.gif" class="image right" style="max-width:60%; 
							max-height:100%; margin: 0em 1em 0em 1em;">
							<h2>WHAT WENT RIGHT</h2>
							<ul>
								<li>
									Developer tools creating using ScriptableObjects and Gizmos allowed for designers to design and implement attacks without having to directly
									code or work extensively alongside programmers
								</li>
								<li>
									Division of boss implementation into State Machine, Attack, and Projectiles allowed for a modular system that allowed fast prototpying and 
									creation, and the system was stable enough that it is being considered for future WolverineSoft Studio Projects
								</li>
								<li>
									Usage of Confluence Collaboration Software allowed for designers, artists, and audio engineers to easily look up documentation for assets 
									created by programmers, and prototype using them without the direction of a programmer
								</li>
							</ul>
							<br><br><br>
							<img src="images/Io/Io_2.gif" class="image left" style="max-width:60%; 
							max-height:100%; margin: 0em 3em 1em 1em;">
							<h2>WHAT COULD BE IMPROVED</h2>
							<ul>
								<li>
									Because progress was far slower than initially anticipated, severe downscoping was required, with only 2 levels left of 
									the original 6, and 1 boss instead of 2
								</li>
								<li>
									Sprint deadlines were often not meant, with tasks being worked on days after they where due, and many tasks were pushed to 
									the backlog and future sprints, causing work to pile up
								</li>
								<li>
									Playtesting, while extensive, was not done enough, resulting in game-breaking bugs in implementation being discovered very 
									late into prodcution, forcing programmers to work overtime to fix them
								</li>
							</ul>
							<br><br><br>
							<a href="http://bit.ly/EECS493" class="image"></a><img src="images/Io/Io_3.png" class="image right" style="max-width:60%; 
							max-height:100%; margin: 0em 1em 0em 1em;">
							
							<h2>LESSONS LEARNED</h2>
							<ul>
								<li>
									Task assignment must be done with far more care, taking into consideration any unexpected circumstances that may cause them to take
									 far more time, and sprint deadlines must be enforced more strictly to avoid work piling up
								</li>
								<li>
									Extensive playtesting must be done for not only features and design, but also for any custom tools that were created for the projcet
								</li>
								<li>
									While downscoping happens during the development process of almost every game, it should be taken in consideration during preproduction 
									to prevent very large segments being removed after work has already been done
								</li>
						</div>
					</section>
					<section id="main" class="wrapper style3 fullscreen fade-up"">
						<div class="inner">
							<h1 class="major">CONTRIBUTIONS</h1>
							<p>
								My major contribution to this project was the implementaiton of the ScriptableObject that stored the data of an 
								indiviual type of boss attack, and the tool that allowed developers to easily create their own attack without 
								touching code, through the Unity Inspector and Scene Editor. The boss system was initially divided into 3 parts, 
								the State Machine, which controlled the behavior of the boss, the BossAttackScriptableObject, which stored the 
								properties of the attack, such as the animations, and coordinates for the projectiles, and the Projectile prefab, 
								which was the individual projectiles that would be instantiated by the BossAttackScriptableObject, which was in 
								turn called on by the State Machine. The ScriptableObject stores a list of possible projectile prefabs, and 
								coordinates and rotation, and prefab type for each projectile that is instantiated, and the animation that the 
								boss will go through. The ScriptableObject itself has an Attack() function that instantiates all the selected 
								prefabs, at the stored coordinates and rotations. I utilized a CustomEditor script to create the Editor interface 
								from scratch. There is a empty ObjectField where a designer can drag in prefabs that will used in the attack, which 
								are added to an internal List. A dropdown field of all the stored prefabs is underneath it, allowing each prefab 
								to be removed from the list. Underneath that, is IntField to decide the number of projectiles that will be 
								instantiated, and fields for the type of prefab, coordinates, and rotation of each projectile are automatically 
								added or removed underneath this as the number of projectiles are changed. Up until this point was fairly simple, 
								albeit time consuming to implement. The difficult part was the creation of a tool that allows the designers to 
								easily create their own attacks. The method I used was having a Gizmo be rendered at the location of each projectile, 
								and handles on the Gizmo that allow the coordinates and rotation to be changed by clicking and dragging on them, without 
								having to input exact numbers in the Editor. However, I encountered many difficulties. <br> 
								Unlike almost any kind of Object class in Unity, Gizmos do not have a Transform component, and their global location and 
								rotation are stored in a Matrix4x4 format using Quaternions. Converting to and fro from Matrix4x4 to Vector3 is 
								extremely tedious, but it is possible by creating a new one of either, and using Unity's conversion functions. 
								The big problem was making the location and rotation of the Gizmo correspond to the transform data stored in the 
								ScriptableObject when it is stored. I ended up using a very obtuse system that involves multiple conversions between 
								data types, and how I did this and why I did so can be found in the Dev Blog for Io, linked below.

								<br>

								Another big problem that occured later was a bug that caused the data stored in the ScriptableObject to randomly be reset. 
								After extensive research, I discovered that this was because, unlike any changes made to an Object that is in the currently 
								open scene, a ScriptableObject is not automatically checked for changes, and is only checked in specific circumstances, 
								such as the object itself being exited, or a save not having occured for a long time. So, any changes made in the Editor 
								would not be saved to disk on ctrl+s, resulting in them reset whenever Unity was closed and opened again. This was fixed 
								by manually marking any changes as dirty in the CustomEditor script.
							</p>
							<ul class="actions">
								<li><a href="ProjectBlue_devblog.html" class="button">Io Dev Blog</a></li>
							</ul>
						</div>
					</section>
			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Seyhyun Yang. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>